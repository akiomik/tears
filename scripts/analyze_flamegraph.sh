#!/usr/bin/env bash
# Flame graph analysis script for tears framework
# 
# Usage: ./scripts/analyze_flamegraph.sh <flamegraph.svg>
#
# This script extracts and analyzes performance data from flamegraph SVG files
# generated by cargo-flamegraph or inferno.

set -euo pipefail

# Color codes for output
RED='\033[0;31m'
YELLOW='\033[1;33m'
GREEN='\033[0;32m'
BLUE='\033[0;34m'
BOLD='\033[1m'
NC='\033[0m' # No Color

if [ $# -eq 0 ]; then
    echo "Usage: $0 <flamegraph.svg>"
    exit 1
fi

FLAMEGRAPH_FILE="$1"

if [ ! -f "$FLAMEGRAPH_FILE" ]; then
    echo "Error: File '$FLAMEGRAPH_FILE' not found"
    exit 1
fi

echo -e "${BOLD}=== Flamegraph Analysis ===${NC}"
echo "File: $FLAMEGRAPH_FILE"
echo ""

# Extract all stack traces with sample counts
TEMP_DATA=$(mktemp)
grep -o '<title>[^<]*</title>' "$FLAMEGRAPH_FILE" | \
    sed 's/<title>//g' | \
    sed 's/<\/title>//g' | \
    grep -v '^$' > "$TEMP_DATA"

# Calculate total samples
TOTAL_SAMPLES=$(grep -oE '\([0-9]+ samples,' "$TEMP_DATA" | \
    sed 's/(\([0-9]*\) samples.*/\1/' | \
    awk '{sum+=$1} END {print sum}')

echo -e "${BLUE}Total samples: $TOTAL_SAMPLES${NC}"
echo ""

# Extract hotspots (functions with their sample counts and percentages)
echo -e "${BOLD}=== Top Hotspots (by sample count) ===${NC}"
grep -oE '.* \([0-9]+ samples, [0-9.]+%\)' "$TEMP_DATA" | \
    sed 's/\(.*\) (\([0-9]*\) samples, \([0-9.]*\)%)/\2|\3|\1/' | \
    sort -t'|' -k1 -rn | \
    head -30 | \
    awk -F'|' -v total="$TOTAL_SAMPLES" '{
        samples=$1; 
        percent=$2; 
        name=$3;
        # Decode HTML entities
        gsub(/&lt;/, "<", name);
        gsub(/&gt;/, ">", name);
        gsub(/&amp;/, "\\&", name);
        
        # Color coding based on percentage
        if (percent >= 10.0) {
            color="\033[0;31m"; # Red for >= 10%
        } else if (percent >= 5.0) {
            color="\033[1;33m"; # Yellow for >= 5%
        } else if (percent >= 1.0) {
            color="\033[0;32m"; # Green for >= 1%
        } else {
            color=""; # No color for < 1%
        }
        printf "%s%6d samples (%5.1f%%) %s\033[0m\n", color, samples, percent, name;
    }'

echo ""
echo -e "${BOLD}=== Category Breakdown ===${NC}"

# Categorize by component
echo ""
echo -e "${YELLOW}Terminal/Crossterm:${NC}"
grep -E 'crossterm|ratatui.*terminal|std::fs::OpenOptions.*open' "$TEMP_DATA" | \
    grep -oE '\([0-9]+ samples, [0-9.]+%\)' | \
    sed 's/(\([0-9]*\) samples, \([0-9.]*\)%)/\1 \2/' | \
    sort -rn | head -10 | \
    awk '{printf "  %6d samples (%5.1f%%)\n", $1, $2}'

echo ""
echo -e "${YELLOW}Ratatui Rendering:${NC}"
grep -E 'ratatui.*buffer|ratatui.*text|ratatui.*widget|ratatui.*draw' "$TEMP_DATA" | \
    grep -oE '\([0-9]+ samples, [0-9.]+%\)' | \
    sed 's/(\([0-9]*\) samples, \([0-9.]*\)%)/\1 \2/' | \
    sort -rn | head -10 | \
    awk '{printf "  %6d samples (%5.1f%%)\n", $1, $2}'

echo ""
echo -e "${YELLOW}Tokio Runtime:${NC}"
grep -E 'tokio::runtime|tokio::time|tokio::sync|parking_lot' "$TEMP_DATA" | \
    grep -oE '\([0-9]+ samples, [0-9.]+%\)' | \
    sed 's/(\([0-9]*\) samples, \([0-9.]*\)%)/\1 \2/' | \
    sort -rn | head -10 | \
    awk '{printf "  %6d samples (%5.1f%%)\n", $1, $2}'

echo ""
echo -e "${YELLOW}Tears Framework:${NC}"
grep -E 'tears::' "$TEMP_DATA" | \
    grep -oE '\([0-9]+ samples, [0-9.]+%\)' | \
    sed 's/(\([0-9]*\) samples, \([0-9.]*\)%)/\1 \2/' | \
    sort -rn | head -10 | \
    awk '{printf "  %6d samples (%5.1f%%)\n", $1, $2}'

echo ""
echo -e "${YELLOW}System Calls:${NC}"
grep -E 'libsystem_kernel|libsystem_c|libsystem_pthread|libsystem_malloc' "$TEMP_DATA" | \
    grep -oE '\([0-9]+ samples, [0-9.]+%\)' | \
    sed 's/(\([0-9]*\) samples, \([0-9.]*\)%)/\1 \2/' | \
    sort -rn | head -10 | \
    awk '{printf "  %6d samples (%5.1f%%)\n", $1, $2}'

# Identify specific bottlenecks
echo ""
echo -e "${BOLD}=== Identified Bottlenecks ===${NC}"

# Check for terminal size operations
TERMINAL_SIZE_SAMPLES=$(grep -E 'crossterm::terminal.*size|std::fs::OpenOptions.*open.*tty' "$TEMP_DATA" | \
    grep -oE '\([0-9]+ samples,' | \
    sed 's/(\([0-9]*\) samples.*/\1/' | \
    awk '{sum+=$1} END {print sum+0}')

if [ "$TERMINAL_SIZE_SAMPLES" -gt 0 ]; then
    TERMINAL_SIZE_PERCENT=$(awk -v samples="$TERMINAL_SIZE_SAMPLES" -v total="$TOTAL_SAMPLES" \
        'BEGIN {printf "%.1f", (samples/total)*100}')
    echo -e "${RED}ðŸ”´ Terminal size queries: $TERMINAL_SIZE_SAMPLES samples ($TERMINAL_SIZE_PERCENT%)${NC}"
    echo "   Issue: Opening /dev/tty repeatedly to query terminal size"
    echo "   Fix: Cache terminal size, update only on resize events"
fi

# Check for buffer diff operations
BUFFER_DIFF_SAMPLES=$(grep -E 'Buffer::diff|Cell.*PartialEq' "$TEMP_DATA" | \
    grep -oE '\([0-9]+ samples,' | \
    sed 's/(\([0-9]*\) samples.*/\1/' | \
    awk '{sum+=$1} END {print sum+0}')

if [ "$BUFFER_DIFF_SAMPLES" -gt 0 ]; then
    BUFFER_DIFF_PERCENT=$(awk -v samples="$BUFFER_DIFF_SAMPLES" -v total="$TOTAL_SAMPLES" \
        'BEGIN {printf "%.1f", (samples/total)*100}')
    echo -e "${YELLOW}ðŸŸ¡ Buffer diffing: $BUFFER_DIFF_SAMPLES samples ($BUFFER_DIFF_PERCENT%)${NC}"
    echo "   Issue: Comparing entire buffer every frame"
    echo "   Fix: Implement dirty flag, skip rendering when no changes"
fi

# Check for parking/idle time
PARK_SAMPLES=$(grep -E 'park|psynch_cvwait' "$TEMP_DATA" | \
    grep -oE '\([0-9]+ samples,' | \
    sed 's/(\([0-9]*\) samples.*/\1/' | \
    awk '{sum+=$1} END {print sum+0}')

if [ "$PARK_SAMPLES" -gt 0 ]; then
    PARK_PERCENT=$(awk -v samples="$PARK_SAMPLES" -v total="$TOTAL_SAMPLES" \
        'BEGIN {printf "%.1f", (samples/total)*100}')
    echo -e "${GREEN}ðŸŸ¢ Idle/waiting: $PARK_SAMPLES samples ($PARK_PERCENT%)${NC}"
    echo "   Note: This is expected idle time (normal)"
fi

# Cleanup
rm -f "$TEMP_DATA"

echo ""
echo -e "${BOLD}=== Recommendations ===${NC}"
echo "1. Optimize terminal size queries (highest impact)"
echo "2. Implement dirty flag for conditional rendering"
echo "3. Consider adaptive frame rate based on activity"
echo ""
